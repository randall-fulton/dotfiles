#+PROPERTY: header-args  :tangle configuration.el
#+PROPERTY: header-args+ :eval never
#+PROPERTY: header-args+ :exports code

** Globals

#+begin_src elisp
  (defvar rf/source-code-font
    (concat "Fira Code "
	    (cond ((eq system-type 'darwin) "16")
		  ((eq system-type 'gnu/linux) "12")
		  ((eq system-type 'windows-nt) "12"))))
#+end_src

** Package management

Straight is used to manage package installation, with the
=use-package= integration.

#+begin_src elisp
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
  (setq straight-vc-git-default-protocol 'https)
  (setq straight-vc-git-force-protocol nil)

  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src

** Emacs defaults

/DISABLED: doesn't play nicely with tiling WMs/
Always start maximized.

#+begin_src elisp :tangle no
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

Don't show the dreaded startup screen.

#+begin_src elisp
  (setq inhibit-startup-screen t)
#+end_src

Stop the stupid bell sound. I /know/ that did nothing Emacs, but I want
to hit =C-g= 80 times anyway!
#+begin_src elisp
  (setq ring-bell-function 'ignore)
#+end_src

Remove GUI decorations, to present a plain window.

#+begin_src elisp
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
#+end_src

Set the default working directory and show it in dired on startup.

(Disabled because it causes two buffers to be opened when Emacs is started from a terminal with =emacs . &=. Need to find a way to only do this when emacs wasn't launched for a particular directory.)

#+begin_src elisp :tangle no
  (setq default-directory
		(cond ((equal system-type 'windows-nt) "G:\\Developer")
			  (t "~/dev"))
		)

  (setq initial-buffer-choice default-directory)
#+end_src

Put all backup files in a central location. Prevents triggering tools like =gotestsum= every time an Emacs backup happens.

Must be a relative path. If absolute, this will be ignored on Windows, due to MS-DOS systems not (elegantly) supporting long line names. See [[https://lists.gnu.org/archive/html/bug-gnu-emacs/2014-07/msg00160.html][bug#17938]]. (Not always true. Msys appears to appropriately handle backups, but I'd prefer a solution that has zero edge cases.)

#+begin_src elisp
  (setq backup-directory-alist `(("." . ".saves"))
        auto-save-default nil)
#+end_src

Global code formatting rules.

Customize code style through font, theme, ligatures, etc.

#+begin_src elisp
  (set-frame-font rf/source-code-font nil t)

  (use-package modus-themes
    :init
    (setq modus-themes-bold-constructs t
          modus-themes-org-blocks 'gray-background)
    :config (load-theme 'modus-operandi)
    :bind (("C-c M-a t t" . modus-themes-toggle)))

  (use-package ligature
    :load-path "path-to-ligature-repo"
    :config
    ;; Enable the "www" ligature in every possible major mode
    (ligature-set-ligatures 't '("www"))
    ;; Enable traditional ligature support in eww-mode, if the
    ;; `variable-pitch' face supports it
    (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
    ;; Enable all Cascadia Code ligatures in programming modes
    (ligature-set-ligatures '(prog-mode) ; org-mode)
                            '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                              ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                              "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                              "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                              "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                              "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                              "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                              "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                              ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                              "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                              "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                              "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                              "\\\\" "://"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))
#+end_src

To use icons in =doom-modeline= we have to have =all-the-icons=. After installing the package, run =M-x all-the-icons-install-fonts= to get required icon fonts.
#+begin_src elisp
  (use-package all-the-icons)
#+end_src

Mode line
#+begin_src elisp
  (use-package doom-modeline
    :init
    (require 'all-the-icons)
    (doom-modeline-mode 1)
    :config
    (setq doom-modeline-height 50))
#+end_src

Helpful editor customizations to make code navigation easier.

#+begin_src elisp
  (setq display-line-numbers-type 'relative)
  (add-hook #'prog-mode-hook #'display-line-numbers-mode)
#+end_src

*** Path

Ensure Emacs shares =$PATH= with a normal shell. Without this, some executables won't be
available (e.g. =rust-analyzer=).

#+begin_src elisp
  (setq-default explicit-shell-file-name
                (cond ((eq system-type 'darwin) "zsh")
                      ((eq system-type 'gnu/linux) "/usr/bin/zsh")
                      ((eq system-type 'windows-nt) "bash")))

  (use-package exec-path-from-shell
    :ensure t
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+end_src

*** Keybinds

Change =other-window= to allow for easy forward and backward
navigation. Much more fluid movement, reminiscent of Vim.

#+begin_src elisp
  (global-unset-key (kbd "C-x o"))
  (global-set-key (kbd "C-,")
				  (lambda () (interactive) (other-window -1)))
  (global-set-key (kbd "C-.")
				  (lambda () (interactive) (other-window 1)))
#+end_src

Open this file for editing.

#+begin_src elisp
  (defun rf/config-edit ()
    "Open configuration file"
    (interactive)
    (find-file (expand-file-name "configuration.org" user-emacs-directory)))
  (global-set-key (kbd "C-c c") '("config-edit" . rf/config-edit))
#+end_src

Use =ibuffer= instead of =list-buffers=.
#+begin_src elisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

** Workflow
Utilities for non-dev tasks (e.g. email).

Would love to use for email, but can't get it to work on darwin.
#+begin_src elisp :tangle no
  (use-package mu4e)
#+end_src

** Org Setup
Extended set of todo states.
#+begin_src elisp
  (defconst rf/todo-states "#+todo: TODO(t) DOING(d) MEET(m) | DONE(f) CANCELED(c)"
    "Extended todo states. Should be used across all `org-agenda' accessible files.")
#+end_src

Extension to =org-roam= to support weekly files.
#+begin_src elisp
  (defun rf/format-week-id (&optional offset)
    "Create string identifying week OFFSET weeks in future in format
  '<YEAR> Week <WEEK NUM>'. Weeks start on Monday."
    (let* ((offset-seconds (* 60 60 24 7 (or offset 0)))
           (target-week (time-add (current-time)
                                  offset-seconds)))
      (concat
       (format-time-string "%Y" target-week)
       " Week "
       (format-time-string "%W" target-week))))

  (defun rf/org-roam-goto-weekly (arg)
    "Open weekly file for current week, creating it if it does not
  exist. Serves as a collection point for an entire week of
  dailies. Use with prefix to open ARG weeks in future."
    (interactive "P")
    (let* ((org-roam-directory (expand-file-name org-roam-dailies-directory
                                                 org-roam-directory))
           (weekly-file-id (rf/format-week-id arg))
           (weekly-file-name (concat (string-replace " " "_" weekly-file-id) ".org"))
           (weekly-file-path (expand-file-name weekly-file-name
                                               org-roam-directory))
           (new-file-p (not (f-exists-p weekly-file-path))))
      (find-file weekly-file-path)
      (when new-file-p
        (insert (concat "#+title: " weekly-file-id "\n\n")
                rf/todo-states
                "* Goals\n\n"
                "* Monday\n\n"
                "* Tuesday\n\n"
                "* Wednesday\n\n"
                "* Thursday\n\n"
                "* Friday\n\n")
        (beginning-of-buffer)
        (org-id-get-create))))
#+end_src

Update agenda files. Setting them on startup won't take into account
new files that are created in a session. Since I tend to keep a single
Emacs running for days, that would be a problem.
#+begin_src elisp
  (defun rf/org-agenda-set-agenda-files ()
    "Update `org-agenda-files' to include all org-roam files."
    (interactive)
    (setq org-agenda-files (append (directory-files "~/org/work" t ".org$")
                                   (directory-files "~/org/roam/daily" t ".org$"))))
#+end_src

Org roam for Zettelkasten and roam UI to explore in browser, similar to Obsidian GUI.
#+begin_src elisp
  (use-package org-roam
    :custom
    (org-roam-directory (file-truename "~/org/roam"))
    (org-roam-dailies-directory (file-truename "~/org/roam/daily"))
    (org-roam-dailies-capture-templates `(("d" "default" entry "* %?" :target
                                           (file+head "%<%Y-%m-%d>.org"
                                                      ,(concat rf/todo-states "\n"
                                                               "#+title: %<%Y-%m-%d>" "\n\n"
                                                               "* Highlights" "\n")))))
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n i" . org-roam-node-insert)
           ;; dailies
           ;; ("C-c n y" . org-roam-dailies-goto-yesterday)
           ;; ("C-c n d" . org-roam-dailies-goto-today)
           ;; ("C-c n t" . org-roam-dailies-goto-tomorrow)
           ("C-c n w" . rf/org-roam-goto-weekly)
           ("C-c n a" . (lambda () (interactive)
                          (find-file (file-truename "~/org/work/daily.org"))))
           ;; agenda (really doesn't belong here, but 'C-c a' is taken)
           ("C-c n r" . rf/org-agenda-set-agenda-files))
    :bind-keymap
    ("C-c n d" . org-roam-dailies-map)
    :config
    (require 'org-roam-dailies)
    (org-roam-setup)
    (org-roam-db-autosync-mode))

  (use-package org-roam-ui
    :after org-roam
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src

Org table keymap.
#+begin_src elisp
  (defalias 'rf/org-table-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "c") 'org-table-insert-column)
      (define-key map (kbd "h") 'org-table-insert-hline)
      (define-key map (kbd "r") 'org-table-insert-row)
      (define-key map (kbd "s") 'org-table-sort-lines)
      map)
    "Bindings for editing org tables.")
#+end_src

#+begin_src elisp
  (defun rf/configure-org ()
    ;; vars
    (setq org-pretty-entities t
          org-hide-leading-star t
          org-hide-emphasis-markers t
          org-log-done t
          org-startup-indented t)

    (require 'org-id)
    (add-to-list 'org-modules 'org-id)
    (setq org-id-link-to-org-use-id t)

    ;; keybinds
    (unbind-key (kbd "C-,") org-mode-map)
    (define-key org-mode-map (kbd "C-c f b") 'org-indent-block)
    (define-key org-mode-map (kbd "C-c i") 'org-toggle-inline-images)
    (define-key org-mode-map (kbd "C-c a") 'org-agenda)
    (define-key org-mode-map (kbd "C-c t") 'rf/org-table-map)
    (define-key org-mode-map (kbd "C-c l i") 'org-insert-last-stored-link)
    (define-key org-mode-map (kbd "C-c l l") 'org-insert-link)
    (define-key org-mode-map (kbd "C-c l s") 'org-id-store-link)

    ;; babel languages
    (org-babel-do-load-languages 'org-babel-load-languages
                                 '((shell . t)
                                   (dot . t)))

    ;; style
    (variable-pitch-mode)
    (visual-line-mode)
    (let* ((variable-tuple
            (cond ((x-list-fonts "ETBembo")      '(:font "ETBembo"))
                  ((x-family-fonts "Sans Serif") '(:family "Sans Serif"))
                  (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
           (base-font-color     (face-foreground 'default nil 'default))
           (headline           `(:inherit default :weight bold :foreground ,base-font-color)))
      (custom-theme-set-faces
       'user
       `(variable-pitch ((t (,@variable-tuple :height 180 :weight thin))))
       `(fixed-pitch ((t (:font ,rf/source-code-font :height 180))))
       `(org-level-8 ((t (,@headline ,@variable-tuple))))
       `(org-level-7 ((t (,@headline ,@variable-tuple))))
       `(org-level-6 ((t (,@headline ,@variable-tuple))))
       `(org-level-5 ((t (,@headline ,@variable-tuple))))
       `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
       `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
       `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
       `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
       `(org-document-title ((t (,@headline ,@variable-tuple :height 2.0 :underline nil))))
       '(org-code ((t (:inherit (shadow fixed-pitch)))))
       '(org-block ((t (:inherit fixed-pitch))))
       '(org-document-info ((t (:foreground "dark orange"))))
       '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
       '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
       '(org-link ((t (:foreground "royal blue" :underline t))))
       '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
       '(org-property-value ((t (:inherit fixed-pitch))) t)
       '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
       '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
       '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
       '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))))

  (add-hook #'org-mode-hook #'rf/configure-org)
  (rf/org-agenda-set-agenda-files)
#+end_src

Pandoc-powered exporter. Helpful for Markdown, as the default exporter doesn't add language to source blocks in exported document.
#+begin_src elisp
  (use-package ox-pandoc)
#+end_src

Graphviz is used in my Zettelkasten to create diagrams.
#+begin_src elisp
  (use-package graphviz-dot-mode)
#+end_src

** Utilities
*** Buffer Keymap
All of the functionality under =C-c C-b=. It's buffer-specific.

Run =multi-occur= in the current buffer only.
#+begin_src elisp
  (defun rf/multi-occur (regexp)
    "Run MULTI-OCCUR in the active buffer."
    (interactive "sSearch regexp: ")
    (multi-occur `(,(current-buffer)) regexp))
#+end_src

Setup a keymap for all buffer-specific commands.
#+begin_src elisp
  (global-set-key (kbd "C-c C-b") 'rf/buffer-map)

  (defalias 'rf/buffer-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "s") 'rf/multi-occur)
      map)
    "Bindings for current buffer.")
#+end_src

*** Quality of Life packages

#+begin_src elisp
  (use-package magit
	:ensure t)
  (use-package which-key
	:ensure t
	:config
	(which-key-mode))
#+end_src

Support for multiple cursors, similar to other modern editors (e.g. VS Code).

While using multiple cursors =C-j= must be used for newlines.
#+begin_src elisp
  (use-package multiple-cursors
    :bind (("C-M-n" . 'mc/mark-next-like-this)
           ("C-M-k" . 'mc/skip-to-next-like-this)
           ("C-M-p" . 'mc/unmark-previous-like-this))
    :custom ((mc/always-run-for-all t)))
#+end_src

Conditionally rebind a key when a given predicate is true. Useful for overriding an existing keybind only in very specific situations (e.g. when mark is set).

Ran into issues using this for =multiple-cursors=, so not 100% it works perfectly. Leaving here for now though, as it has the potential to be quite useful.

Modified from [[https://stackoverflow.com/a/16323678/21591799][this Stack Overflow answer]].
#+begin_src elisp
  (defmacro rf/define-key-with-fallback (keymap key def condition)
    "Binds KEY to definition DEF in KEYMAP. Binding is only active
     when CONDITION is true."
    `(define-key ,keymap ,key
       (lambda () (interactive)
	 (if ,condition (progn ,def (print "overridden"))
	   (call-interactively (key-binding ,key))))))
#+end_src

Highlight =TODO= and =NOTE= comments. This needs to be manually added as a hook on target major modes. It is not enabled globally.
#+begin_src elisp
  (defun rf/buffer-highlight-todo (&optional buf)
    "Enable highlighting of TODO/NOTE comments in BUF. Will target
     active buffer when BUF is not provided."
    (interactive)
    (or buf (setq buf (current-buffer)))
    (with-current-buffer buf
      (hi-lock-face-phrase-buffer "TODO" 'modus-themes-intense-magenta)
      (hi-lock-face-phrase-buffer "NOTE" 'bold)))
#+end_src

Open a side buffer containing a list of all =TODO= comments in current buffer.

#+begin_src elisp
  (defun rf/todo-open-list (&optional nlines)
    "Do a `projectile-multi-occur' for all TODOs in project."
    (interactive "P")
    (let ((project (projectile-acquire-root)))
      (multi-occur (projectile-project-buffers project)
		   "TODO"
		   nlines)))
#+end_src

*** TODO filter out non-code buffers

** Terminal

Eshell is nice, but it doesn't play well with tools that expect a "full-featured" terminal. Using =ansi-term= doesn't work too well in those cases either. (See =bacon test=, for example.)

#+begin_src elisp
  (unless (eq system-type 'windows-nt)
    (use-package vterm
      :custom ((vterm-shell "zsh"))))
#+end_src

** IDE

Advanced functionality to turn Emacs into a full-blown IDE.

*** Completion

Ivy. It's better than Ido, but who knows about helm...

In this context, "completion" refers to interactions with the
minibuffer and eshell. LSP completion is not handled by ivy.

#+begin_src elisp
  (use-package ivy
	:ensure t
	:config
	(ivy-mode))
#+end_src

*** LSP

#+begin_src elisp
  (use-package company)

  (use-package lsp-ui
    :bind (("C-c o" . lsp-ui-imenu))
    :custom
    (lsp-ui-imenu-window-fix-width t)
    (lsp-ui-doc-enable nil) ; causes issues with yabai
    (lsp-ui-doc-show-with-cursor t)
    (lsp-ui-doc-delay 1)
    (lsp-ui-doc-position 'at-point))

  (use-package lsp-mode
    :init
    (setq lsp-keymap-prefix "C-c l")
    :commands lsp
    :custom
    (lsp-rust-analyzer-cargo-watch-command "clippy"))
#+end_src

*** Projectile
Package =rg= is required for projectile-ripgrep.

#+begin_src elisp
  (use-package rg)
  (use-package projectile
    :bind ("C-c p" . projectile-command-map)
    :init
    (projectile-mode +1)
    (projectile-register-project-type 'go '("go.mod")
				      :project-file "go.mod"
				      :compile "go build"
				      :test "go test"
				      :run "go run ./..."
				      :test-suffix "_test.go"))
#+end_src

*** Syntax checks

**** TODO how do I plug in extra tools to flycheck
**** TODO better keybinds to quickly jump between errors

#+begin_src elisp
  (use-package flycheck
	:bind
	(("M-p" . flycheck-previous-error)
	 ("M-n" . flycheck-next-error)))
#+end_src

*** Snippets

Yasnippet isn't configured with any snippets by default, so we have to create them ourselves or use another package.

Luckily, there is a fairly comprehensive one. =M-x yas-describe-tables= provides a list of available snippets.

#+begin_src elisp
  (use-package yasnippet-snippets)
#+end_src

Yasnippet itself is enabled as a per-mode minor-mode, using hooks. It can also be setup as a global mode.

#+begin_src elisp
  (use-package yasnippet
    :bind (:map yas-minor-mode-map
		("M-/" . yas-expand)
		("TAB" . nil))
    :config (yas-reload-all))
#+end_src

*** Treesitter (Disabled)

The following only works with Emacs 29+. Follow [[https://git.savannah.gnu.org/cgit/emacs.git/tree/admin/notes/tree-sitter/starter-guide?h=feature/tree-sitter][this guide]] to setup
tree-sitter.

This still has a huge drawback: it replaces language modes with
tree-sitter equivalents. This would sound great, except the
replacement modes are not yet full-featured. For example, =go-ts-mode=
has improper highlighting, indentation, and requires separate
configuration to =go-mode=.

#+begin_src elisp :tangle no
  (defun treesit-install-all-languages ()
	"Install all languages specified by `treesit-language-source-alist'."
	(interactive)
	(let ((languages (mapcar 'car treesit-language-source-alist)))
	  (dolist (lang languages)
		(treesit-install-language-grammar lang)
		(message "`%s' parser was installed." lang)
		(sit-for 0.75))))

  (defun treesit-initialize ()
	"Initialize tree-sitter."
	(interactive)
	(setq treesit-extra-load-path '("~/dev/tree-sitter-module/dist"))
	(setq treesit-language-source-alist
		  '((bash . ("https://github.com/tree-sitter/tree-sitter-bash"))
			(c . ("https://github.com/tree-sitter/tree-sitter-c"))
			(cpp . ("https://github.com/tree-sitter/tree-sitter-cpp"))
			(go . ("https://github.com/tree-sitter/tree-sitter-go"))
			(gomod . ("https://github.com/camdencheek/tree-sitter-go-mod"))
			(json . ("https://github.com/tree-sitter/tree-sitter-json"))
			(make . ("https://github.com/alemuller/tree-sitter-make"))
			(python . ("https://github.com/tree-sitter/tree-sitter-python"))
			(rust . ("https://github.com/tree-sitter/tree-sitter-rust"))
			(toml . ("https://github.com/tree-sitter/tree-sitter-toml"))))
	(when (treesit-available-p)
	  (require 'treesit)
	  ;; (treesit-install-all-languages)
	  (when (treesit-ready-p 'go t)
		(add-to-list 'major-mode-remap-alist '(go-mode . go-ts-mode)))))

  (when (and (not (version< emacs-version "29"))
			 (treesit-available-p))
	(treesit-initialize)
	(use-package tester
	  :ensure t
	  :straight (tester
				 :type git
				 :host github
				 :repo "randall-fulton/tester.el")))
#+end_src

*** Languages

**** C
#+begin_src elisp
  (use-package company-ctags)
#+end_src

Align macros so that line-ending backslashes are aligned.
#+begin_src elisp
  (defun rf/c-align-macro (begin end)
    (interactive "r")
    (align-regexp
     begin
     end
     "\\(\\s-*\\)\\\\[[:space:]]*$"
     1 1 nil))
#+end_src

Formatting keybinds. (Not working. Can't remember how. :shrug)
#+begin_src elisp :tangle no
  (defalias 'rf/c-format-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "m") 'rf/c-align-macro)
      map)
    "Bindings for formatting various C constructs.")
#+end_src

#+begin_src elisp
  (defun rf/setup-c-mode ()
    "Setup c-mode"
    (add-hook 'c-mode-hook #'yas-minor-mode)
    (add-hook 'c-mode-hook #'company-mode)
    (add-hook 'c-mode-hook #'company-ctags-auto-setup)
    (add-hook 'c-mode-hook
	      (lambda ()
		(define-key c-mode-map
		  (kbd "C-c f m")
		  'rf/c-align-macro))))

  (rf/setup-c-mode)
#+end_src

**** Docker

#+begin_src elisp
  (use-package dockerfile-mode)
#+end_src

**** GLSL

#+begin_src elisp
  (use-package glsl-mode)
#+end_src

**** Go

****** TODO use =gofumpt= on-save

****** TODO add snippet for =t.Run()=

****** TODO use =gotestsum= for auto-testing

#+begin_src elisp
    (use-package go-mode
      :bind (("C-c C-c C-c" . tester-run-current-test))
      :config
      (add-hook 'go-mode-hook #'lsp-deferred)
      (add-hook 'before-save-hook #'lsp-format-buffer)
      (add-hook 'before-save-hook #'lsp-organize-imports)
      (add-hook 'go-mode-hook #'yas-minor-mode))
    (use-package ob-go
      :straight (ob-go
                 :type git
                 :host github
                 :repo "pope/ob-go"))
#+end_src

To support files with build-tags in lsp-mode, use something like the following in dir-locals.
#+begin_src lisp-data :export none :tangle no
   ((go-mode . (lsp-gopls-build-flags . ["-tags=unit,integration"])))
#+end_src

**** Haskell

#+begin_src elisp
  (use-package haskell-mode
	:config
	(add-hook 'haskell-mode-hook #'lsp-deferred)
	(add-hook 'haskell-mode-hook #'flycheck-mode)
	:init
	(use-package lsp-haskell)
	(use-package hindent))
#+end_src

**** Lisp

#+begin_src elisp
  (use-package parinfer-rust-mode
    :hook (emacs-lisp-mode lisp-mode)
    :init
    (setq parinfer-rust-auto-download t))
  (use-package slime
    :init
    (setq inferior-lisp-program "sbcl --dynamic-space-size 4096")
    (setq browse-url-handlers
	  '(("hyperspec" . eww-browse-url)
	    ("." . browse-url-default-browser))))
#+end_src

Parinfer doesn't work well with other minor modes that manage whitespace. If we don't disable =indent-tabs-mode=, really strange behavior happens when editing Lisp.
#+begin_src elisp
  (defun rf/disable-indent-tabs-for-lisp (mode-hooks)
    "Disable indent-tabs-mode for all MODE-HOOKS."
    (dolist (hook mode-hooks)
      (add-hook hook #'(lambda() (indent-tabs-mode -1)))))
  (rf/disable-indent-tabs-for-lisp '(emacs-lisp-mode-hook lisp-mode-hook))
#+end_src

**** Nix

#+begin_src elisp
  (use-package nix-mode)
#+end_src

**** Protobuf
#+begin_src elisp
  (use-package protobuf-mode)
#+end_src

**** Python

#+begin_src elisp
  (use-package lsp-pyright
    :hook (python-mode . (lambda ()
			   (require 'lsp-pyright)
			   (lsp))))

  (use-package python-black
    :after python
    :hook (python-mode . python-black-on-save-mode-enable-dwim))
#+end_src

**** Odin

#+begin_src elisp
  (use-package odin-mode
    :straight
    (odin-mode :type git :host github :repo "mattt-b/odin-mode")
    :config
    (setq-default lsp-auto-guess-root t)
    (defvar lsp-language-id-configuration '((odin-mode . "odin")))
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection "g:/Developer/odin/ols/ols.exe")
		      :major-modes '(odin-mode)
		      :server-id 'ols
		      :multi-root t))
    (add-hook 'odin-mode-hook #'lsp-deferred))
#+end_src

**** Ruby

#+begin_src elisp
  (add-hook 'ruby-mode-hook #'lsp-deferred)
#+end_src

**** Rust
Lookup a =std= identifier on Rust docs. Necessary because =rustic='s Org integration doesn't work on Windows. Unfortunately, this doesn't work either because =eww= can't understand the Rust docs site (angrily shakes fist at JavaScript).
#+begin_src elisp :tangle no
  (defun rf/rust-search ()
    "Search for identifier under cursor."
    (interactive)
    (let ((term (thing-at-point 'word 'no-properties)))
      (eww (format "https://doc.rust-lang.org/std/index.html?search=%s" term))))
#+end_src

When using =tracing= and =tracing_subscriber= crates, logs have ANSI escape codes by default. The following function will parse those in a given buffer and convert them to Emacs faces. This can be added to =compilation-finish-functions= to parse all ANSI sequences after compilation completes.
#+begin_src elisp
  (require 'ansi-color)
  (defun rf/display-ansi-colors-in-buffer (&optional buf)
    "Enable ANSI colors in BUF"
    (interactive)
    (or buf (setq buf (current-buffer)))
    (let ((inhibit-read-only t))
      (with-current-buffer buf
	(ansi-color-apply-on-region (point-min) (point-max)))))
#+end_src

#+begin_src elisp
  (use-package rustic
    :hook (lsp-deferred
	   (rustic-mode . rf/buffer-highlight-todo))
    :init
    (setq lsp-rust-analyzer-server-display-inlay-hints t)
    :config
    (add-hook 'before-save-hook #'lsp-format-buffer)
    (add-hook 'before-save-hook #'lsp-organize-imports)
    (add-hook 'rust-mode-hook #'yas-minor-mode)
    (add-hook 'compilation-finish-functions
	      #'(lambda (buf &rest ignored)
		  (rf/display-ansi-colors-in-buffer buf))))
#+end_src

***** TODO use =bacon= for auto-testing
***** TODO update struct/enum snippets to auto-derive =Debug=

**** Typescript
#+begin_src elisp
  (use-package typescript-mode)
#+end_src

**** Yaml

#+begin_src elisp
  (use-package yaml-mode)
#+end_src
